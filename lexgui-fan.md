Lex规范的结构

lex程序由三部分组成：定义段、规则段和用户子例程序段

...定义段...

%%

...规则段...

%%

...用户子例程序段...

这些部分由以两个百分号组成的行分隔开。尽管某一部分可以为空，但前两部分是必须的，第三部分和前面的%%行可以忽略。

定义段

定义段包括文字块、定义、内部表声明、起始条件和转换。

以空白开头的行被逐字拷贝到C文件中，通常，这用于包含包围在/\*和\*/中的注释，一般前面有空白。

规则段

规则段包含模式行和C代码，以空白开始的行或者包围在%{和%}中的内容是C代码。以任何其他形式开始的行是模式行。

C代码被逐字拷贝到生成的C文件中。

当lex扫描程序运行时，它把输入与规则段的模式进行匹配。每次发现一个匹配（被匹配的输入称为标记（token））时就执行与那种模式相关的C代码。如果模式后面跟着\|符号，则该模式将使用与文件中下一个模式相同的C代码。当输入字符不匹配模式时，词法分析程序的动作就好像它匹配上了代码ECHO的模式，ECHO将标记的拷贝写到输出。

用户子例程序段

用户子例程序段的内容被lex逐字拷贝到C文件，这一部分通常包括从规则中调用的例程。如果重新定义input\(\)、unput\(\)、output\(\)、或者yywrap\(\)，新的版本或者支持子程序，都可以放在这里。

lex库

大多数lex实现都需要有用的例程库，通过在UNIX系统的cc命令行的结尾（或其它系统的等价物上）给出-ll 标志来链入库。库的内容根据实现的不同有所改变，但它总是包含main\(\)。

main\(\)

lex的所有版本都有最小的main\(\)程序，它对于简短程序和测试都是很有用的。它非常简单，内容如下:

```
main(argc,argv)
int argc;
char **argv;
{
      yylex();
      return 0;
}
int yywrap()
{
      return 1;
}
```

yyleng\(\)

只要是在扫描程序匹配标记时，标记的文本就被存储在以空字符终止的字符串yytext中，而它的长度存在yyleng中， yyleng\(\)返回的值与strlen\(yytext\)返回的值是相同的。



yylex\(\)

由lex创建的扫描程序有入口点yylex\(\)。调用yylex\(\)启动或重新开始扫描。如果lex动作执行将数值传递给调用程序的return，那么yylex\(\)的下次调用就从它停止的地方继续。



yywrap\(\)

当词法分析程序遇到文件结尾时，它调用例程yywrap\(\)来找出下一步要做什么，如果yywrap\(\)返回0，则扫描程序就继续扫描，如果返回1，则扫描程序就返回报告文件结尾的零标记。



lex库中的yywrap\(\)的标准版本总是返回1，但是可以用自己的值来替代它，如果yywrap\(\)返回指示有更多输入的0，那么它首先需要调整指向新文件的yyin，可能需要使用fopen\(\)。

[https://blog.csdn.net/fly\_yr/article/details/42969381](https://blog.csdn.net/fly_yr/article/details/42969381)

