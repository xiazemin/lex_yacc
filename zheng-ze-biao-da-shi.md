正则表达式语法

lex模式是由编辑程序和实用程序使用的正则表达式的扩展版本。正则表达式由常规字符（代表它们本身）和元字符（在一种模式中具有特殊含义）组成。



元字符

.

. 匹配除了换行符 \n 之外的任意单个字符



\[\]

\[\] 匹配括号中字符的任意一个。用“-”（短划线）指示字符的范围，例如\[0-9\]指10个数字中的任意一个。如果开括号之后的第一个字符是短划线或者闭括号，那么它就不能被解释为元字符。如果第一个字符是抑扬字符“ ^ ”，那么它的含义就变为匹配括号内字符以外的任意字符。除了以“ \ ”开始的C转义序列被识别以外，其他的元字符在方括号中没有特殊含义。



\*

\* 匹配前面正则表达式的零次或者多次出现。



+

+ 匹配前面正则表达式的一次或者多次出现。



?

? 匹配前面正则表达式的零次或者一次出现。例如： -?\[0-9\]+  指具有可选的前导或者一元减号的数字



{}

{} 意味着根据括号内部的不同而不同。单个数字{n}意味着前面的模式重复n次。例如： \[A-Z\]{3} 表示任意3个大写字母。



如果大括号包含的由逗号分开的两个数字{n,m}，那么它们是前面模式重复的最小数和最大数。例如：A{1,3}表示字母A出现1次到3次。



如果第二个数字丢失就意味着无穷大，所以{1，}意味着 +    ；  {0，}意味着 \*  。



如果大括号包含一个名字，它指示用那个名字来替换。



\

\ 转义符号，如果后面的字符是小写字母，那么它就是C转义序列。 例如制表位：\t



一些实现允许采用如“\123” 和 “\x3f” 这种形式的八进制和十六进制字符。



否则，“\” 引用后面的字符，所以 \\* 匹配一个 \* 号。



\(\)

\(\) 将一系列正则表达式归组。 \*   +   {}   中的每一个都直接作用于它左侧的表达式，而且 \|  通常同时影响左侧和右侧的内容。圆括号可以改变这种情况，



例如：（ab\|cd）?ef  匹配 abef  或者 cdef 或者只是 ef



\|

\| 匹配前面的或者随后的表达式。



“...”

“...” 逐字匹配引号内的每个字符。不同于“\”的元字符会失去它的含义。



例如：“/\*” 匹配两个字符 /\*



/

/ 只有当有后面的表达式跟随时才匹配前面的表达式。



例如： 0/1 匹配字符串01中的0 但是不匹配字符串0或者02中的任何字符。



每个模式只允许有一个/ ，并且模式不能同时包含 / 和 $



^

^ 作为正则表达式的第一个字符，它匹配行的开始，它还在方括号中用于否定。



$

$ 作为正则表达式的最后一个字符，它匹配行的结束



&lt;&gt;

&lt;&gt; 位于模式开头的尖括号内的一个或者一列名字，使那个模式只应用于指定的起始状态。



《EOF》

《EOF》 只用于flex中，这个特殊模式匹配文件的结尾。

[https://blog.csdn.net/fly\_yr/article/details/42969493](https://blog.csdn.net/fly_yr/article/details/42969493)

